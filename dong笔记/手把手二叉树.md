---


---

<h1 id="二叉树">二叉树</h1>
<blockquote>
<ul>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247487126&amp;idx=1&amp;sn=4de13e66397bc35970963c5a1330ce18&amp;chksm=9bd7f09eaca0798853c41fba05ad5fa958b31054eba18b69c785ae92f4bd8e4cc7a2179d7838&amp;scene=21#wechat_redirect">手把手带你刷二叉树（第一期）</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247487270&amp;idx=1&amp;sn=2f7ad74aabc88b53d94012ceccbe51be&amp;chksm=9bd7f12eaca078384733168971147866c140496cb257946f8170f05e46d16099f3eef98d39d9&amp;scene=21#wechat_redirect">手把手带你刷二叉树（第二期）</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247487527&amp;idx=1&amp;sn=9cf2b0d8608ba26ea7c6a5c9b41d05a1&amp;chksm=9bd7ee2faca0673916bf075539bf6fc3c01f3dcc0b298b3f507047692ef5c850ed9cfe82e4e6&amp;scene=21#wechat_redirect">手把手带你刷二叉树（第三期）</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247488101&amp;idx=1&amp;sn=6041ddda5f20ccde8a7036d3e3a1482c&amp;chksm=9bd7ec6daca0657b2ab20a936437e2c8206384c3b1485fe91747ad796fa3a5b08556b2f4911e&amp;scene=21#wechat_redirect">手把手带你刷二叉搜索树（第一期）</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247488128&amp;idx=2&amp;sn=b8fb3fd2917f9ac86127054741cd5877&amp;chksm=9bd7ec88aca0659ee0185b657663169169493e9df2063fa4d28b38a0b4d0dd698d0301937898&amp;scene=21#wechat_redirect">手把手带你刷二叉搜索树（第二期）</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247485871&amp;idx=1&amp;sn=bcb24ea8927995b585629a8b9caeed01&amp;chksm=9bd7f7a7aca07eb1b4c330382a4e0b916ef5a82ca48db28908ab16563e28a376b5ca6805bec2&amp;scene=21#wechat_redirect">二叉树的序列化，就那几个框架，枯燥至极</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247485629&amp;idx=1&amp;sn=fc0d0fc2b8618a9b8a575cfa9d5b1c4a&amp;chksm=9bd7f6b5aca07fa33c4fbce0dc439359592ace091814fdcdc0742f336722398090396f0b3668&amp;scene=21#wechat_redirect">题目不让我干什么，我偏要干什么</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247485561&amp;idx=1&amp;sn=a394ba978283819da1eb34a256f6915b&amp;chksm=9bd7f671aca07f6722f0bc1e946ca771a0a40fd8173cc1227a7e0eabfe4e2fcc57b9ba464547&amp;scene=21#wechat_redirect">Git原理之最近公共祖先</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247485057&amp;idx=1&amp;sn=45a3b89a4efef236cb662d5505d7ce36&amp;chksm=9bd7f889aca0719f4915de681f983355e187151030991ab1944494ffe4b73e484068b85eb01e&amp;scene=21#wechat_redirect">如何计算完全二叉树的节点数</a></li>
</ul>
<p>两遍笔记，onenote手写一遍，stackeidt复习 效果很好<br>
但我目前每道题只会一种解法</p>
</blockquote>
<p>题目涉及：</p>

<table>
<thead>
<tr>
<th>No.</th>
<th>题目</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://leetcode-cn.com/problems/invert-binary-tree/">226</a></td>
<td>翻转二叉树，难度 <strong>Easy</strong></td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">114</a></td>
<td>将二叉树展开为链表，难度 <strong>Medium</strong></td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">116</a></td>
<td>填充二叉树节点的右侧指针，难度 <strong>Medium</strong></td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/maximum-binary-tree/">654</a></td>
<td>最大二叉树（难度  <strong>Medium</strong>）</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105</a></td>
<td>从前序与中序遍历序列构造二叉树（难度  <strong>Medium</strong>）</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106</a></td>
<td>从中序与后序遍历序列构造二叉树（难度  <strong>Medium</strong>）</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/find-duplicate-subtrees/">652</a></td>
<td>寻找重复子树（<strong>Medium</strong>）</td>
</tr>
<tr>
<td>230</td>
<td>BST第K小的元素（Medium）</td>
</tr>
<tr>
<td>538</td>
<td>二叉搜索树转化累加树（Medium）</td>
</tr>
<tr>
<td>1038</td>
<td>BST 转累加树（Medium）</td>
</tr>
</tbody>
</table><p>总结：<strong>写递归算法的关键是要明确函数的「定义」是什么，然后相信这个定义，利用这个定义推导最终结果，绝不要试图跳入递归</strong>。<br>
<strong>写树相关的算法，简单说就是，先搞清楚当前<code>root</code>节点该做什么，然后根据函数定义递归调用子节点</strong>，递归调用会让孩子节点做相同的事情。</p>
<h2 id="二叉树第一期"><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247487126&amp;idx=1&amp;sn=4de13e66397bc35970963c5a1330ce18&amp;chksm=9bd7f09eaca0798853c41fba05ad5fa958b31054eba18b69c785ae92f4bd8e4cc7a2179d7838&amp;scene=21#wechat_redirect">二叉树第一期</a></h2>
<h4 id="翻转二叉树"><a href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a></h4>
<p>自顶向下 前序遍历</p>
<ul>
<li>// base case<br>
// 两个已经递归好的子树<br>
// 对root操作</li>
</ul>
<p>自底向上，后序遍历</p>
<ul>
<li>// base case<br>
// 两个已经递归好的子树<br>
// 对root操作</li>
</ul>
<p>首先讲这道题目是想告诉你，<strong>二叉树题目的一个难点就是，如何把题目的要求细化成每个节点需要做的事情</strong>。</p>
<h4 id="填充每个节点的下一个右侧节点指针"><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></h4>
<p>从简单-&gt;复杂思考</p>
<h4 id="二叉树展开为链表"><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h4>
<p>你看，这就是递归的魅力，你说<code>flatten</code>函数是怎么把左右子树拉平的？不容易说清楚，<strong>但是只要知道<code>flatten</code>的定义如此，相信这个定义，让<code>root</code>做它该做的事情，然后<code>flatten</code>函数就会按照定义工作。</strong></p>
<p>另外注意递归框架是后序遍历，因为我们要先拉平左右子树才能进行后续操作。</p>
<p>至此，这道题也解决了，我们旧文  <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247484597&amp;idx=1&amp;sn=c603f1752e33cb2701e371d84254aee2&amp;chksm=9bd7fabdaca073abd512d8fff18016c9092ede45fed65c307852c65a2026d8568ee294563c78&amp;scene=21#wechat_redirect">递归思维：k 个一组反转链表</a> 的递归思路和本题也有一些类似。</p>
<h2 id="二叉树第二期"><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247487270&amp;idx=1&amp;sn=2f7ad74aabc88b53d94012ceccbe51be&amp;chksm=9bd7f12eaca078384733168971147866c140496cb257946f8170f05e46d16099f3eef98d39d9&amp;scene=21#wechat_redirect">二叉树第二期</a></h2>
<h4 id="最大二叉树"><a href="https://leetcode-cn.com/problems/maximum-binary-tree/">654.最大二叉树</a></h4>
<ul>
<li>找到最大值，记录index<br>
左子树=递归左边的，右子树=递归右边的</li>
</ul>
<p>模式：<br>
<strong>对于每个根节点，只需要找到当前<code>nums</code>中的最大值和对应的索引，然后递归调用左右数组构造左右子树即可</strong>。</p>
<p>明确了思路，我们可以重新写一个辅助函数<code>build</code>，来控制<code>nums</code>的索引</p>
<h4 id="从前序与中序遍历序列构造二叉树"><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h4>
<p>和上一题 模式 一样：<br>
<strong>对于每个根节点，只需要找到当前<code>rootval</code>中对应的 <em>根节点</em>（前序遍历） 和<em>对应的索引</em>（中序遍历），然后递归调用<em>左右数组</em>（中序遍历）构造左右子树即可</strong>。<br>
明确了思路，我们可以重新写一个辅助函数<code>build</code>，来控制 参数 的索引</p>
<h4 id="从中序与后序遍历序列构造二叉树"><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h4>
<p>有了前一题的铺垫，这道题很快就解决了，无非就是<code>rootVal</code>变成了最后一个元素，再改改递归函数的参数而已，只要明白二叉树的特性，也不难写出来。</p>
<p>最后呼应下前文，<strong>做二叉树的问题，关键是把题目的要求细化，搞清楚根节点应该做什么，然后剩下的事情抛给前/中/后序的遍历框架就行了</strong>。</p>
<h2 id="二叉树第三期"><a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247487527&amp;idx=1&amp;sn=9cf2b0d8608ba26ea7c6a5c9b41d05a1&amp;chksm=9bd7ee2faca0673916bf075539bf6fc3c01f3dcc0b298b3f507047692ef5c850ed9cfe82e4e6&amp;scene=21#wechat_redirect">二叉树第三期</a></h2>
<h4 id="寻找重复的子树"><a href="https://leetcode-cn.com/problems/find-duplicate-subtrees/">652. 寻找重复的子树</a></h4>
<h2 id="二叉搜索树（第一期）"><a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247488101&amp;idx=1&amp;sn=6041ddda5f20ccde8a7036d3e3a1482c&amp;chksm=9bd7ec6daca0657b2ab20a936437e2c8206384c3b1485fe91747ad796fa3a5b08556b2f4911e&amp;scene=21#wechat_redirect">二叉搜索树（第一期）</a></h2>
<h2 id="二叉搜索树（第二期）"><a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247488128&amp;idx=2&amp;sn=b8fb3fd2917f9ac86127054741cd5877&amp;chksm=9bd7ec88aca0659ee0185b657663169169493e9df2063fa4d28b38a0b4d0dd698d0301937898&amp;scene=21#wechat_redirect">二叉搜索树（第二期）</a></h2>

